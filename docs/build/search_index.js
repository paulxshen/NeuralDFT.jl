var documenterSearchIndex = {"docs":
[{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Star us on Github","category":"page"},{"location":"#Synopsis","page":"Home","title":"Synopsis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NeuralDFT.jl implements in Julia an equivariant machine learning (ML) model for predicting the 3D electronic density distribution and atomic force fields of molecules and crystals. It can act as both an fast scalable ML surrogate for density functional theory (DFT) calculations in predicting properties or as a DFT accelerator by supplying a more accurate initial density for self-consistent field (SCF) iterations. The model's rotation and translation equivariance (covariance) assures symmetry preservation. ","category":"page"},{"location":"#Electron-density-importance","page":"Home","title":"Electron density importance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Electron density is of central importance in quantum chemistry and materials science. It's a physical observable and the starting point in self consistent calculations in ab initio electronic structure computational methods like density functional theory (DFT) and Hartree-Fock (HF) for determining key properties like energy, forces, stability and band gap of chemicals and materials. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"<!–-  It's the –>","category":"page"},{"location":"#Machine-learning-for-electron-density","page":"Home","title":"Machine learning for electron density","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Machine learning for electron density can both accelerate ab initio methods and replace them in predicting properties. Electronic structure calculations suffer from superlinear scaling. DFT scales as O(n^3), making it computational taxing for medium sized systems and prohibitive for very large systems. ML on the other hand scales linearly as O(n). DFT iteratively refine the density so a good initial density predicted by machine learning can accelerate convergence and reduce computational cost. Alternately, many properties can be directly computed from electron density including forces via electrostatic integration and consequently relaxed geometry plus phonon states. One can also estimate the energy using empirical energy density functionals.","category":"page"},{"location":"#Project-status","page":"Home","title":"Project status","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Collaborators welcome for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"DFT acceleration: work is mostly already done, just needs someone to write it up and finish benchmarking. See tutorial for DFTK.jl integration \nForce fields for MD / structural relaxation: proof of concept see tutorial. can get accurate forces by electrostatic integration of density. needs demo on real problem\nTrain density models on your system of choice eg electrolytes, catalysts... can do a few application specific papers\nHost as web API: relevant if you wanna do SWE/SDE in industry, wrap code in Julia container and push to AWS/GCP","category":"page"},{"location":"#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Paul Shen pxshen@alumni.stanford.edu  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Former research staff with Professor Venkat Viswanathan venkvis@cmu.edu","category":"page"},{"location":"guide/#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"guide/#Prediction","page":"Guide","title":"Prediction","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"DensityPredictor(::AbstractMatrix)\r\nForceField\r\ntrain","category":"page"},{"location":"guide/#Main.NeuralDFT.DensityPredictor-Tuple{AbstractMatrix}","page":"Guide","title":"Main.NeuralDFT.DensityPredictor","text":"DensityPredictor(cell, model)\nDensityPredictor(domain, resolution, model)\n(m::DensityPredictor)(Z, pos, sz; periodic, origin)\n\nConstructs DensityPredictor which is callable for Predicting valence electron density. It instantiates equivariant kernels at the specified discretisation setting and computes the prediction using DensityModel parameters. \n\nArgs\n\ncell: column-wise matrix of discretization cell vectors\nZ: list of atomic numbers\npos: column wise position matrix of atoms in Z. size of 3 x # electrons.\nsz: integer size (pixel dimensions) of domain grid\nperiodic: set to true for crystal lattices / periodic boundaries\norigin: indices of the origin when specifying positions, may be decimal valued\ndomain: 3 x 3 matrix with columns as bounding Vectors for the domain.\nresolution: discretisation length\n\n\n\n\n\n","category":"method"},{"location":"guide/#Main.NeuralDFT.ForceField","page":"Guide","title":"Main.NeuralDFT.ForceField","text":"ForceField(cell)\n(m::ForceField)(Z, pos, ρ,; [origin],[cell], [periodic]  )\n\nConstructs ForceField which is callable for computing forces when given valence electron density. It instantiates kernels at the specified discretisation setting and computes force fields via FFT. discretisation at construction and usage can be different. if discretisation of the valence density is different from that of ForceField functor, the former must be supplied as a keyword cell when calling the latter\n\nArgs\n\ncell: column-wise matrix of discretization cell vectors\nZ: list of atomic numbers\npos: column wise position matrix of atoms in Z. size of 3 x # electrons.\nρ: valence electron density\nperiodic: set to true for crystal lattices / periodic boundaries\norigin: indices of the origin when specifying positions, may be decimal valued\n\n\n\n\n\n","category":"type"},{"location":"guide/#Main.NeuralDFT.train","page":"Guide","title":"Main.NeuralDFT.train","text":"train(data; nsamples=100)\n\nTrains a DensityModel from data\n\nArgs\n\nnsamples: # samples / cubic bohr\ndata: list of cases each of which has the fields:\nZ: list of atomic numbers\npos: column wise position matrix of atoms in Z. size of 3 x # electrons.\nsz: integer size (pixel dimensions) of domain grid\nperiodic: set to true for crystal lattices / periodic boundaries\ndomain: 3 x 3 matrix with columns as bounding Vectors for the domain.\norigin: indices of the origin when specifying positions, may be decimal valued\n\n\n\n\n\n","category":"function"},{"location":"guide/#Pretrained-models","page":"Guide","title":"Pretrained models","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"DEMO1: trained on small smaple of organic molecules including alcohols, aldehydes","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"DEMO2: trained on small smaple of","category":"page"},{"location":"tutorials/#tutorials","page":"tutorials","title":"tutorials","text":"","category":"section"},{"location":"tutorials/","page":"tutorials","title":"tutorials","text":"DFT acceleration","category":"page"},{"location":"dft/#DFT-acceleration","page":"DFT acceleration","title":"DFT acceleration","text":"","category":"section"},{"location":"dft/","page":"DFT acceleration","title":"DFT acceleration","text":"\"\"\"\r\nwe compare electron density predicted by ML vs computed by DFT, noting reduction in SCF iterations by starting with an ML density vs SAD density\r\n\"\"\"\r\n\r\nusing DFTK\r\nusing LinearAlgebra\r\nusing FileIO\r\nusing UnPack\r\nusing PeriodicTable\r\nusing DataStructures\r\nusing EquivariantOperators\r\n\r\n# include(\"../src/NeuralDFT.jl\")\r\n# using .NeuralDFT\r\ninclude(\"../src/pretrained.jl\")\r\ninclude(\"utils_DFTK.jl\")\r\n\r\n# we use an older version of DFTK because I'm unable to get the newest version to build correctly. Install in REPL: ]add DFTK@0.3.10\r\n\r\n# whether to re-instantiate models or load them from cache file\r\nreset = true\r\n# reset=false\r\n\r\n# atomic numbers \r\nZ = [6, 6, 8, 1, 1, 1, 1, 1, 1]\r\n\r\npos = 1.88973 * [\r\n    -0.0086050396 1.5020382883 -0.0068121748;\r\n    0.0109931006 -0.0176487687 -0.013770355;\r\n    0.6808884095 -0.4404180314 -1.1931320987;\r\n    1.0115333417 1.896620303 -0.0192015475;\r\n    -0.5315986204 1.8807610923 -0.8897465868;\r\n    -0.5167457158 1.876117708 0.8871073864;\r\n    0.5237712083 -0.3891229547 0.8882408183;\r\n    -1.0202754406 -0.4050726108 0.0169067033;\r\n    0.6952957263 -1.4017956761 -1.2014849452;\r\n]'\r\n\r\n# slightly offset the positions so origin is near the molecule's center\r\ncenter!(pos)\r\n\r\n# a x a x a lattice\r\na = 12\r\nlattice = a * I(3)\r\n\r\n# offset the positions so origin is at (1, 1, 1) of lattice array with the molecule centered in lattice\r\npos .+= a / 2\r\n\r\n##==========\r\n# DFT calculation with SAD initial density\r\n\r\n# DFT parameters, refer to DFTK.jl docs\r\nEcut = 40\r\nkgrid = [1, 1, 1]\r\ntol = 1e-2\r\n\r\natoms = DefaultOrderedDict(Vector)\r\nfor (a, x) in zip(Z, eachcol(pos))\r\n    xr = lattice \\ x\r\n    push!(atoms[psp[a]], xr)\r\nend\r\natoms = collect(atoms)\r\n\r\nmodel = model_LDA(lattice, atoms)\r\nbasis = PlaneWaveBasis(model, Ecut; kgrid=kgrid)\r\nρ = ρ_SAD = guess_density(basis)\r\nscfres = self_consistent_field(basis; ρ,\r\n    tol)\r\n# ρ_SAD=guess_density(basis)\r\nforces = compute_forces_cart(scfres)\r\nforces = hcat(vcat(forces...)...)\r\n\r\n@unpack energies, ρ = scfres\r\nρ_DFT = ρ[:, :, :, 1]\r\nρ_SAD = ρ_SAD[:, :, :, 1]\r\n\r\ns=volume(ρ_DFT)\r\n# display(s)\r\nsave(\"etoh.png\",s)\r\n\r\ns=volume(ρ_SAD)\r\n# display(s)\r\nsave(\"etohsad.png\",s)\r\n##==========================\r\n\r\n##===============\r\n# repeat DFT with ML predicted density\r\n\r\nd = \".\"\r\nif !reset #\r\n    predictor = load(\"$d\\\\demo1_predictor.jld2\", \"predictor\")\r\nelse\r\n    resolution = 0.15\r\n    cell = resolution * I(3)\r\n    model = DEMO1\r\n    predictor = DensityPredictor(cell, model)\r\n    save(\"$d\\\\demo1_predictor.jld2\", \"predictor\", predictor)\r\nend\r\n\r\ndomain = lattice\r\nsz = size(ρ_SAD)\r\norigin = ones(3)\r\nperiodic = false\r\n\r\n# density prediction result\r\nρ_ML = predictor(Z, pos, domain, sz; periodic, origin)\r\n@show nae(ρ_ML, ρ_DFT)\r\n@show nae(ρ_SAD, ρ_DFT)\r\n\r\ns=volume(ρ_ML)\r\n# display(s)\r\nsave(\"etohml.png\",s)\r\n\r\n# rerun DFT\r\n# ρ = reshape(ρ_ML, sz..., 1)\r\n# scfres = self_consistent_field(basis; ρ,\r\n#     tol);","category":"page"},{"location":"dft/#Output","page":"DFT acceleration","title":"Output","text":"","category":"section"},{"location":"dft/","page":"DFT acceleration","title":"DFT acceleration","text":"(Image: )","category":"page"},{"location":"dft/","page":"DFT acceleration","title":"DFT acceleration","text":"<!– (Image: ) –>","category":"page"},{"location":"dft/","page":"DFT acceleration","title":"DFT acceleration","text":"n     Energy            Eₙ-Eₙ₋₁     ρout-ρin   α      Diag\r\n---   ---------------   ---------   --------   ----   ----\r\n  1   -261.2259656906         NaN   4.88e-01   0.80   13.0\r\n  2   -267.3105476010   -6.08e+00   2.10e-01   0.80    3.0\r\n  3   -266.8053137845    5.05e-01   1.48e-01   0.80    5.0\r\n  4   -266.0474887135    7.58e-01   3.00e-02   0.80    3.0\r\n  5   -266.7987616624   -7.51e-01   9.09e-03   0.80    3.0\r\n  6   -266.6789659157    1.20e-01   1.79e-03   0.80    3.0\r\n  7   -266.6922824556   -1.33e-02   9.89e-04   0.80    3.0\r\n  8   -266.6816123533    1.07e-02   1.22e-04   0.80    3.0\r\n  9   -266.6834088550   -1.80e-03   3.13e-05   0.80    4.0\r\n\r\nnae(ρ_ML, ρ_DFT) = 0.03266530392327634\r\nnae(ρ_SAD, ρ_DFT) = 0.2013599127594411","category":"page"},{"location":"dft/","page":"DFT acceleration","title":"DFT acceleration","text":"DFT with conventional superposition of atomic density (SAD) guess, taking 4 iterations to reach density deviation of a few percent. SAD errs around 20% while our ML prediction errs 3% corresponding to reduction of 4 SCFs here. DFTK.jl treats the initial guess as highly inaccurate and needs small modification to capitalize on the much more accurate initial density","category":"page"},{"location":"basics/#Basics:-predicting-electron-density-and-force-fields","page":"Basics: predicting electron density and force fields","title":"Basics: predicting electron density and force fields","text":"","category":"section"},{"location":"basics/","page":"Basics: predicting electron density and force fields","title":"Basics: predicting electron density and force fields","text":"\"\"\"\r\nwe predict density and forces on equilibrium and distorted geometries of CH4\r\n\"\"\"\r\n\r\nusing FileIO\r\nusing Random\r\nusing Statistics\r\nusing UnPack\r\nRandom.seed!(1)\r\nusing GLMakie: volume\r\nusing LinearAlgebra\r\nusing EquivariantOperators\r\ninclude(\"../src/pretrained.jl\")\r\n\r\n# whether to re-instantiate models or load them from cache file\r\nreset = true\r\n# reset=false\r\n\r\n# CH4 atomic numbers\r\nZ = [6, 1, 1, 1, 1]\r\n\r\n# positions in Bohr (1 Angstrom = 1.88973 Bohr)\r\npos0 = 1.88973 * [\r\n    -0.0126981359 1.0858041578 0.0080009958\r\n    0.002150416 -0.0060313176 0.0019761204\r\n    1.0117308433 1.4637511618 0.0002765748\r\n    -0.540815069 1.4475266138 -0.8766437152\r\n    -0.5238136345 1.4379326443 0.9063972942]'\r\ncenter!(pos0)\r\n\r\nif !reset\r\n    d = \".\"\r\n    global predictor = load(\"$d\\\\demo2_predictor.jld2\", \"predictor\")\r\nelse\r\n    resolution = 0.15\r\n    cell = resolution * I(3)\r\n    d = \".\"\r\n    # model = load(\"$d\\\\demo2.jld2\", \"model\")\r\n    model = DEMO2\r\n    global predictor = DensityPredictor(cell, model,)\r\n    d = \".\"\r\n    save(\"$d\\\\demo2_predictor.jld2\", \"predictor\", predictor)\r\nend\r\n\r\n# 8 x 8 x 8 Bohr box domain\r\ndomain = 8 * I(3)\r\norigin = :center\r\nperiodic = false\r\nmode = :verbose\r\n\r\n# density prediction result\r\npos = pos0\r\nres = predictor(Z, pos, domain; periodic, origin, mode)\r\n@unpack ρ, grid = res\r\ns = volume(ρ)\r\ndisplay(s)\r\n# save(\"ch4.png\",s)\r\n\r\n# forces in Hartrees / Bohr\r\nd = \".\"\r\nif !reset\r\n    calc = load(\"$d\\\\calc.jld2\", \"calc\",)\r\nelse\r\n    cell = 0.1I(3)\r\n    calc = ForceField(cell)\r\n    save(\"$d\\\\calc.jld2\", \"calc\", calc)\r\nend\r\n\r\nforces = calc(Z, pos, ρ; origin, cell=predictor.cell)\r\n@info \"forces near equilibrium\"\r\n@info \"CH length: $(norm(pos[:, 1] - pos[:, 2])) Bohr\"\r\ndisplay(forces)\r\n\r\n# compress geometry and recalculate forces\r\npos = 0.9pos0\r\n@info \"forces for compressed geometry\"\r\n@info \"CH length: $(norm(pos[:, 1] - pos[:, 2])) Bohr\"\r\nρ = predictor(Z, pos, domain; periodic, origin)\r\nforces = calc(Z, pos, ρ; origin, cell=predictor.cell)\r\ndisplay(forces)\r\n\r\ns = volume(ρ)\r\ndisplay(s)\r\n# save(\"ch4c.png\",s)\r\n\r\n# geometry relaxation loop - needs to fix stability issues\r\n# for i = 1:12\r\n#     ρ = predictor(Z, pos, domain; periodic, origin)\r\n#     forces .= calc(Z, pos, ρ; origin, cell=predictor.cell)\r\n#     pos .+= .2forces\r\n#     display(forces)\r\n#     @show norm(pos[:, 1] - pos[:, 2])\r\n# end","category":"page"},{"location":"basics/#Output","page":"Basics: predicting electron density and force fields","title":"Output","text":"","category":"section"},{"location":"basics/","page":"Basics: predicting electron density and force fields","title":"Basics: predicting electron density and force fields","text":"(Image: equilibrium CH4)","category":"page"},{"location":"basics/","page":"Basics: predicting electron density and force fields","title":"Basics: predicting electron density and force fields","text":"<!– (Image: equilibrium CH4) –>","category":"page"},{"location":"basics/","page":"Basics: predicting electron density and force fields","title":"Basics: predicting electron density and force fields","text":"[ Info: forces near equilibrium\r\n[ Info: CH length: 2.0634964549624915 Bohr\r\n3×5 Matrix{Float64}:\r\n  0.000827607  -1.74149e-5   0.0176606   -0.00994492  -0.00902619\r\n -0.00785024   -0.0171859    0.00718738   0.00672194   0.0062683\r\n  0.0017415    -4.89954e-5  -4.83321e-5  -0.0150512    0.0147357","category":"page"},{"location":"basics/","page":"Basics: predicting electron density and force fields","title":"Basics: predicting electron density and force fields","text":"(Image: compressed CH4)","category":"page"},{"location":"basics/","page":"Basics: predicting electron density and force fields","title":"Basics: predicting electron density and force fields","text":"<!– (Image: compressed CH4) –>","category":"page"},{"location":"basics/","page":"Basics: predicting electron density and force fields","title":"Basics: predicting electron density and force fields","text":"[ Info: forces for compressed geometry\r\n[ Info: CH length: 1.8571468094662422 Bohr\r\n3×5 Matrix{Float64}:\r\n  0.00604092   0.00111333    0.0957033    -0.0494133  -0.0476794\r\n -0.00396767  -0.100294      0.0354205     0.0340532   0.0338676\r\n  0.00261663  -0.000561355  -0.000580622  -0.0821397   0.0839953","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Install Julia, VisualStudio\ngit clone https://github.com/paulxshen/NeuralDFT.jl\nopen folder in VisualStudio\nstart Julia REPL\n]instantiate to install core dependencies from Project.toml\n]add UnPack,FileIO,JLD2,PeriodicTable,DataStructures,EquivariantOperators,Statistics,GLMakie for tutorials\nif GLMakie: GPU plotting fails to install, just skip plotting by commenting out GLMakie, volume(...) lines. Plots.plot can also plot 3d volumes but it can't be rotated\ntry running tutorial example/basics.jl","category":"page"},{"location":"install/#Optional","page":"Installation","title":"Optional","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"some tutorials use additional packages which can be installed via:\n]add DFTK@0.3.10: has Installation issues - not needed unless you're running comparisons vs DFT. we use an older version of DFTK.jl (planewaves DFT package) because I'm unable to get the newest version to build correctly.\n","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"In case of errors, I'm probably the one that screwed up. slack/email me a screenshot of your life's technical difficulties so I can help :)","category":"page"},{"location":"autodiff/#Automatic-differentiation","page":"Automatic differentiation","title":"Automatic differentiation","text":"","category":"section"},{"location":"autodiff/","page":"Automatic differentiation","title":"Automatic differentiation","text":"Most of the package is compatible with autodiff in Flux and Zygote. Exceptions:","category":"page"},{"location":"autodiff/","page":"Automatic differentiation","title":"Automatic differentiation","text":"may or may not work with FFT convolutions. set alg = :direct if encountering autodiff error\nsome special border options ","category":"page"},{"location":"autodiff/","page":"Automatic differentiation","title":"Automatic differentiation","text":"An alternative autodiff package is Enzyme.jl which works at the LLVM level and can handle limitations in Zygote eg array mutation. It's probably the future of autodiff in Julia/C++ but isn't yet mature.","category":"page"},{"location":"docs/#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"docs/","page":"Guide","title":"Guide","text":"Documentation may not be accurate as this is a beta stage package undergoing changes. Get started with tutorials which are more up to date.","category":"page"},{"location":"docs/#Scalar-and-vector-fields","page":"Guide","title":"Scalar & vector fields","text":"","category":"section"},{"location":"docs/","page":"Guide","title":"Guide","text":"Scalar & vector fields are represented as 2d/3d arrays of canonically scalars or vectors. Array values can alternatively be any type that Supports addition & multiplication.","category":"page"},{"location":"docs/#Customizable-grid","page":"Guide","title":"Customizable grid","text":"","category":"section"},{"location":"docs/","page":"Guide","title":"Guide","text":"predict_density\r\npredict_forces\r\ntrain_density","category":"page"}]
}
